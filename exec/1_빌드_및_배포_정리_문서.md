# **목차**

- [버전 정보](#✅-버전-정보)
- [사전 준비 사항](#🛠️-사전-준비-사항)
- [프론트엔드 배포](#🛠️-프론트엔드-배포)

  <br>

# ✅ 버전 정보

- ## Unity

  - `Unity 6 (6000.0.46f1)`
  - `MCP` - 모델 : **claude**
  - `Python 3.11.9`
  - `Unity Hub & Editor - version 2020.3`
  - `uv` (Python package manager)

- ## AI

  - `python 3.11.9`
  - `VS Code 1.100.2`
  - `ollama v0.7.0` - 모델 : **GEMMA3**
  - `fastapi 0.115.12`
  - `gensim` - 모델 : **word2vec-google-news-300**

- ## FE

  - `Next.js 15.3.2`

- ## 배포

  - `AWS EC2`
  - `Docker`
  - `NGINX`

  <br>

---

# 🛠️ 게임 실행 사전 준비 사항

## 그래픽 드라이버와 CUDA 설치

### 1. NVIDIA 그래픽 드라이버 설치

1. [NVIDIA 드라이버 다운로드](https://www.nvidia.co.kr/Download/index.aspx?lang=kr) 페이지로 이동
2. 자신의 **그래픽 카드**에 맞는 드라이버 검색
3. 드라이버 다운로드 후 설치

### 2. CUDA 설치

1. 터미널(cmd 또는 PowerShell)에서 아래 명령어 실행:

   ```bash
   nvidia-smi
   ```

2. 출력되는 정보에서 **CUDA 버전** 확인

3. 권장 CUDA 버전: **11.8**

> ⚠️ CUDA 버전은 사용하는 GPU 및 드라이버에 따라 다르므로, `nvidia-smi` 결과에 맞춰 설치

  <br>

---

## 🦙 Ollama 설치 및 모델 다운로드

### 1. Ollama 설치

- 공식 사이트: [https://ollama.com/download](https://ollama.com/download)
- 자신의 OS에 맞는 설치 파일 다운로드 및 설치

### 2. 모델 실행 및 다운로드

1. 터미널(cmd)에서 아래 명령어 입력:

   ```bash
   ollama run gemma3
   ```

2. `gemma3` 모델이 다운로드되며, 완료 후 `/bye` 입력 창이 뜨면 정상 설치 완료

  <br>

## 🔗 기타 참고 사항

- `gensim`은 `word2vec-google-news-300` 모델과 함께 사용되므로, 처음 실행 시 모델을 다운로드 받는 데 시간이 걸릴 수 있습니다.
- `fastapi`는 서버 API 구성에 사용되며, 별도로 `uvicorn` 등의 실행 도구가 필요할 수 있습니다.

---
# ⚔️ 게임 실행
- 해당 프로그램을 원할하게 실행하기 위해서는 파이썬 서버와 올라마, 유니티를 모두 실행되어야 합니다.

- 패키지 폴더에서 NewEden.zip 파일의 압축을 해제합니다.

- 패키지 내부의 'RunNewEden.bat' 파일을 실행하면 파이썬 서버(가상환경 세팅 및 의존성  자동 설치)와 올라마, 유니티를 모두 실행하며 모델 다운로드도 자동으로 실행합니다.

- 처음 실행시 모델을 다운로드 받고 모델을 로딩하는데 시간이 걸릴 수 있습니다. 

- 위 작업이 완료되면 서버와 게임이 실행됩니다.
  <br>

---

# 🛠️ 프론트엔드 배포

게임에 대한 설명 제공과 다운로드를 지원하기 위해서 프론트엔드로만 구성된 사이트를 만들어 배포하였습니다.

프로젝트의 레포지토리를 통해 CI/CD 파이프라인은 구축하지 않았지만, AWS EC2 서버에는 프론트엔드 프로젝트만 배포하였습니다. 이유는 다음과 같습니다.

1. 팀의 GitLab 레포지토리에 포함되어 CI/CD 파이프라인을 구축하게 되면 사측에서 제공한 게임 관련 에셋도 EC2 서버에 올라가게 되므로 문제가 생길 수 있음.
2. 프론트엔드 페이지 구현은 팀 단위로 작업하지 않았음

단, 향후 CI/CD 파이프라인 구축을 위한 설정은 완료했으므로 그에 대한 설명은 추가하였습니다.

<br>

## 1) MobaXterm 한글 인코딩 설정

Font charset을 DEFAULT로, Term Charset을 EUC-KR로 변경

한글 파일명이 출력되지 않고 문자가 깨지는 문제를 방지하기 위해 Character set을 변경해야 한다.

<br>

## 2) SSH 접속

1. MobaXterm의 Session에서 SSH를 선택한다.
2. Remote host: (Remote host)
3. Specify username: 체크
4. Specify username: Ubuntu
5. Advanced SSH Settings를 선택하여 추가 세팅 진행

   - Use private key 체크
   - 디렉토리에서 pem키를 찾아 등록

<br>

## 3) 시스템의 타임존을 asia/seoul로 변경하기

1. `sudo dpkg-reconfigure tzdata`을 입력하여 타임존 변경창 열기

2. None of the above, Asia, seoul을 순차적으로 선택

3. 설정 완료 후, 설정한 지역으로 시간이 바뀌었음을 확인

<br>

## 4) EC2 초기 세팅

1. 시스템 패키지 업데이트

   - `sudo apt-get update`

   - `sudo apt-get -y upgrade`

2. 기본 도구 설치

   - `sudo apt install -y git curl wget vim htop net-tools unzip zip software-properties-common`

3. Java(OpenJDK 17) 설치

   - `sudo apt update`

   - `sudo apt install -y openjdk-17-jdk`

4. Java 버전 확인
   - `java -version`

<br>

## 5) Docker 설치

1. 시스템 패키지 업데이트

   - `sudo apt-get update`

2. HTTPS 관련 패키지 설치

   - `sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common`

3. 설치가 정상적으로 완료되었는지 확인

   - ` apt policy apt-transport-https`

4. Docker 공식 GPG 키 추가

   - `curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`

5. Docker 저장소 추가

   - `sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"`

6. 패키지 리스트 업데이트

   - `sudo apt-get update`

7. Docker 설치

   - `sudo apt install -y docker-ce`

8. 도커 버전 확인

   - `docker —version`

9. 현재 사용자를 docker 그룹에 추가

   - `sudo usermod -aG docker $USER`

10. Docker 서비스 시작

    - `sudo systemctl start docker`

11. 서버가 재부팅된 후에도 Docker 서비스가 자동으로 시작되도록 설정

    - `sudo systemctl enable docker`

12. 변경 사항 적용

    - `newgrp docker`

13. 간단한 테스트 컨테이너를 실행하여 Docker가 정상적으로 작동하는 지 확인

    - `docker run hello-world`

<br>

## 6) Docker Compose 설치와 Docker 기본 설정

Docker Compose는 주로 여러 컨테이너를 동시에 관리하는 데 유용하지만, 프론트엔드만 배포하더라도 다음과 같은 이유로 사용할 수 있다.

    - 환경 일관성 유지

    - 간편한 관리

    - 확장성 고려

1. Docker Compose 설치

   - `sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose`

2. 실행 권한을 부여

   - `sudo chmod +x /usr/local/bin/docker-compose`

3. 설치 확인
   - `docker-compose --version`
4. Docker 데몬 설정 파일(예: daemon.json)을 저장할 기본 위치를 마련하기 위해 /etc/docker 디렉토리가 없을 경우 생성
   - `sudo mkdir -p /etc/docker`
5. daemon.json 파일 생성
   - `sudo nano /etc/docker/daemon.json`
6. 파일에 내용 넣기

   ```
   {
   “log-driver”: “json-file”,
   “log-opts”: {
   “max-size”: “10m”,
   “max-file”: “3”
   },
   "iptables": false,
   "live-restore": true,
   "userland-proxy": false
   }

   ```

7. Docker 서비스를 재시작
   - `sudo systemctl restart docker`
8. 현재 실행 중인 컨테이너와 사용 중인 포트 확인
   - `docker ps -a`
9. Docker 네트워크 확인
   - `docker network ls`

<br>

## 7) ufw 방화벽 설정

1. 기본적인 보안사항을 확인하기 위해, SSH 데몬 설정 파일을 확인

   - `sudo nano /etc/ssh/sshd_config`

2. SSH 서비스를 재시작

   - `sudo systemctl restart sshd`

3. 방화벽 상태를 확인

   - `sudo ufw status`

4. ufw 방화벽의 기본 정책 확인

   - `sudo ufw status verdose`

5. HTTPS을 위한 포트 열기

   - `sudo ufw allow 433`

6. FastAPI를 위한 포트 열기
   - `sudo ufw allow 3000`
7. 설정된 규칙 확인
   - `sudo ufw status numbered`

<br>

## 8) Fail2ban 설치

Fail2ban은 로그 파일을 모니터링하여 반복적인 실패 로그인 시도를 탐지하고, 해당 IP를 일정 시간 동안 차단(ban)하는 보안 도구이다.

1. Fail2ban 설치
   - `sudo apt-get install –y fail2ban`
2. Fail2ban 설정 파일 생성
   - `sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local`
3. 편집기로 Fail2ban 설정 파일 열기
   - `sudo nano /etc/fail2ban/jail.local`
4. SSH 섹션을 편집

   - 수정 전

     ```
     [sshd]

     # To use more aggressive sshd modes set filter parameter "mode" in jail.local:
     # normal (default), ddos, extra or aggressive (combines all).
     # See "tests/files/logs/sshd" or "filter.d/sshd.conf" for usage example and details.
     #mode   = normal
     port    = ssh
     logpath = %(sshd_log)s
     backend = %(sshd_backend)s

     ```

   - 수정 후

     ```
     [sshd]


     # To use more aggressive sshd modes set filter parameter "mode" in jail.local:

     # normal (default), ddos, extra or aggressive (combines all).

     # See "tests/files/logs/sshd" or "filter.d/sshd.conf" for usage example and details.

     #mode = normal
     port = ssh
     logpath = %(sshd_log)s
     backend = %(sshd_backend)s
     enabled = true
     filter = sshd
     maxretry = 3
     bantime = 3600

     ```

5. 서버가 재부팅된 후에도 Fail2ban 서비스가 자동으로 시작되도록 설정
   - `sudo systemctl enable fail2ban`
6. Fail2ban 서비스 재시작
   - `sudo systemctl restart fail2ban`

<br>

## 9) 배포 스크립트 설정

1. 배포스크립트를 넣을 scripts 폴더 생성
   - `mkdir –p ~/scripts`
2. deploy.sh 생성

   - `nano ~/scripts/deploy.sh`

3. 실행 권한 부여
   - `chmod + x ~/scripts/deploy.sh`

<br>

## 10) 웹 서버 설정 (Nginx)

1. NginX 설치
   - `sudo apt-get install –y nginx`
2. NginX 버전 확인

   - `nginx -v`

3. NginX 기본 설정 파일 생성

   - `sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak`

4. 파일 열기 및 내용 저장

   - `sudo nano /etc/nginx/sites-available/default.bak `

     ```
     # /etc/nginx/sites-available/default

     # 일반 사이트 설정 (HTTP)
     server {
         listen 80;
         server_name _;  # 모든 호스트명에 매치 (도메인이 없을 경우)

         # 보안 헤더 설정
         add_header X-Frame-Options "SAMEORIGIN";
         add_header X-Content-Type-Options "nosniff";
         add_header X-XSS-Protection "1; mode=block";
         add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.youtube.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self'; media-src 'self'; frame-src https://www.youtube.com;";
         add_header Referrer-Policy "strict-origin-when-cross-origin";

         # 프론트엔드 서버로 프록시
         location / {
             proxy_pass http://localhost:3000;
             proxy_set_header Host $host;
             proxy_set_header X-Real-IP $remote_addr;
             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
             proxy_set_header X-Forwarded-Proto $scheme;

             # WebSocket 지원 (개발 시 필요)
             proxy_http_version 1.1;
             proxy_set_header Upgrade $http_upgrade;
             proxy_set_header Connection "upgrade";

             # 타임아웃 설정
             proxy_connect_timeout 60s;
             proxy_send_timeout 60s;
             proxy_read_timeout 60s;
         }

         # 정적 파일 캐싱 설정
         location /_next/static/ {
             proxy_pass http://localhost:3000/_next/static/;
             proxy_cache_bypass $http_pragma;
             expires 365d;
             add_header Cache-Control "public, max-age=31536000, immutable";
         }

         # 이미지 파일 캐싱 설정
         location /images/ {
             proxy_pass http://localhost:3000/images/;
             proxy_cache_bypass $http_pragma;
             expires 7d;
             add_header Cache-Control "public, max-age=604800";
         }

         # 파비콘 캐싱 설정
         location = /favicon.ico {
             proxy_pass http://localhost:3000/favicon.ico;
             access_log off;
             log_not_found off;
             expires 365d;
             add_header Cache-Control "public, max-age=31536000";
         }

         # gzip 압축 설정
         gzip on;
         gzip_comp_level 6;
         gzip_min_length 256;
         gzip_proxied any;
         gzip_types
             application/javascript
             application/json
             application/x-javascript
             text/css
             text/javascript
             text/plain;
     }
     ```

5. NginX 설정 문법 테스트
   - `sudo nginx -t`
6. NginX 재시작
   - `sudo systemctl restart nginx`
7. NginX 상태 확인
   - `sudo systemctl status nginx`

<br>

## 11) DuckDNS를 이용한 도메인 생성

    DuckDNS에서 서브 도메인 생성하고, DuckDNS에서 제공하는 가이드를 통해 진행한다.

1. 서버에 duckdns 디렉토리 생성

   - `mkdir duckdns`

2. 디렉토리로 이동

   - `cd duckdns`

3. 메인 업데이트 스크립트 파일 생성

   - `vi duck.sh`

4. Duck.sh 파일에 실행 권한을 부여

   - `chmod 700 duck.sh`

5. duck_daemon.sh 파일 생성

   - `vi duck_daemon.sh`

6. 데몬 스크립트 실행 권한 부여

   - `chmod +x duck_daemon.sh`

7. 소유자를 root로 변경

   - `sudo chown root duck_daemon.sh`

8. 권한을 744로 설정

   - `sudo chmod 774 duck_daemon.sh`

9. Root 권한으로 데몬스크립트 실행

   - `sudo ./duckdns.sh`

10. 실행 중인 프로세스를 확인

    - `ps –ef | grep duck`

11. 데몬 스크립트가 부팅 시 자동으로 실행되도록 심볼릭 링크를 생성

    - ` sudo ln -s ~/duckdns/duck_daemon.sh /etc/rc2.d/S10duckdns`

12. 심볼릭 링크가 생성되었는지 확인

    - ` ls -la /etc/rc2.d/`

13. 현재 실행 중인 duck 관련 프로세스를 종료

    - `pkill duck`

14. 부팅 시 실행될 때와 같은 방식으로 스크립트를 실행
    - `sudo /etc/rc2.d/S10duckdns`
15. 프로세스를 확인
    - `ps –ef | grep duck`

<br>

## 12) Nginx 서버 이름 업데이트

Nginx가 올바른 도메인 이름을 인식하고, 해당 도메인으로 들어오는 요청을 적절하게 처리하도록 하기 위해서 진행한다.

1. /etc/nginx/sites-available/default 열기

   - `sudo nano /etc/nginx/sites-available/default`
   - `server_name _`을 `server_name <도메인 이름>.duckdns.org;`으로 변경

2. Nginx 설정 파일의 문법과 구성이 올바른지 테스트
   - `sudo nginx -t`
3. Nginx 서비스를 재시작하여 변경된 설정 적용
   - `sudo systemctl restart nginx`

<br>

## 13) SSL 인증서 설정

Certbot은 Let's Encrypt에서 무료 SSL 인증서를 발급받고 관리할 수 있도록 도와주는 도구이다.

1. Certbot 설치
   - `sudo apt-get install -y certbot python3-certbot-nginx`
2. SSL 인증서 발급

   - `sudo certbot --nginx -d robobo.duckdns.org`

3. 자동 갱신 테스트

   - `sudo certbot renew --dry-run`

4. 기존 인증서 설정 확인

   - `sudo cat /etc/letsencrypt/renewal/p.ssafy.io.conf`

5. 실행 중인 웹 서버 프로세스 확인

   - `sudo ps aux | grep -E 'nginx|apache|httpd’`

6. Nginx로 인증서 재발급

   - `sudo certbot --nginx -d p.ssafy.io`

7. 자동 갱신 테스트

   - `sudo certbot renew --dry-run`

8. `/etc/nginx/sites-available/default` 수정
   - Certbot을 실행하여 SSL 인증서를 설치할 때, Certbot은 NGINX 구성 파일을 자동으로 수정하므로 직접 해당 파일을 수정할 필요는 없다.

<br>

## 14) 자동 보안 업데이트 설정

1.  자동 보안 업데이트 설정
    - `sudo apt-get install -y unattended-upgrades apt-listchanges`
2.  설정 파일 편집

    - `sudo nano /etc/apt/apt.conf.d/50unattended-upgrades`

      ```
      Unattended-Upgrade::Allowed-Origins { "${distro_id}:${distro_codename}"; "${distro_id}:${distro_codename}-security"; };
      Unattended-Upgrade::Package-Blacklist { };
      Unattended-Upgrade::AutoFixInterruptedDpkg "true"; Unattended-Upgrade::MinimalSteps "true"; Unattended-Upgrade::InstallOnShutdown "false"; Unattended-Upgrade::Mail "root"; Unattended-Upgrade::MailOnlyOnError "true"; Unattended-Upgrade::Remove-Unused-Dependencies "true"; Unattended-Upgrade::Automatic-Reboot "false";

      ```

      위와 같이 주석을 해제하여 설정을 완료한다.

3.  APT 패키지 관리자가 자동 업데이트 작업을 주기적으로 실행하도록 구성하는 설정 파일 수정
    - `sudo nano /etc/apt/apt.conf.d/20auto-upgrades`

<br>

## 15) Docker 이미지 보안 스캔 설정

1. Trivy 설치

   - `curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin v0.60.0`

2. 스캔 스크립트 파일 생성

   - `nano ~/scripts/scan_docker_images.sh`
   - 파일 작성

     ```
     #!/bin/bash
     # 이미지 목록 가져오기
     IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "<none>")

     echo "=== Docker Security Scan $(date) ===" > ~/logs/docker_scan.log

     # Trivy 존재 확인
     if command -v trivy &> /dev/null; then
         echo "Using Trivy for vulnerability scanning." >> ~/logs/docker_scan.log
         # Trivy 데이터베이스 업데이트
         trivy --quiet image --download-db-only >> ~/logs/docker_scan.log 2>&1
     fi

     # 각 이미지 검사
     for IMG in $IMAGES; do
         echo "Scanning $IMG..." >> ~/logs/docker_scan.log
         # 기본 이미지 정보 기록
         docker image inspect $IMG --format '{{.RepoDigests}}' >> ~/logs/docker_scan.log
         # Trivy가 있는 경우 취약점 스캔 실행
         if command -v trivy &> /dev/null; then
             trivy image --severity HIGH,CRITICAL $IMG >> ~/logs/docker_scan.log 2>&1
         fi
     done

     # 사용하지 않는 이미지 정리
     echo "Cleaning up unused images..." >> ~/logs/docker_scan.log
     docker image prune -f >> ~/logs/docker_scan.log

     ```

3. 실행 권한 부여

   - `chmod +x ~/scripts/scan_docker_images.sh`

4. 로그 디렉토리 생성

   - `mkdir -p ~/logs`

5. cron 작업 등록

   - `(crontab -l 2>/dev/null; echo "0 3 * * 1 ~/scripts/scan_docker_images.sh") | crontab -`

<br>

## 16) 시스템 로그 모니터링 설정

1. 로그 모니터링 스크립트 생성

   - `nano ~/scripts/check_logs.sh`
   - 파일 작성

     ```
     #!/bin/bash
     LOG_DIR=~/logs
     mkdir -p $LOG_DIR

     # 시스템 로그 요약
     echo "=== System Logs Summary $(date) ===" > $LOG_DIR/daily_summary.log
     grep -i error /var/log/syslog | tail -n 50 >> $LOG_DIR/daily_summary.log

     # Docker 컨테이너 로그 요약
     echo -e "\n=== Docker Container Logs ===" >> $LOG_DIR/daily_summary.log
     docker ps -a >> $LOG_DIR/daily_summary.log
     docker stats --no-stream >> $LOG_DIR/daily_summary.log

     # 디스크 사용량
     echo -e "\n=== Disk Usage ===" >> $LOG_DIR/daily_summary.log
     df -h >> $LOG_DIR/daily_summary.log

     # 메모리 사용량
     echo -e "\n=== Memory Usage ===" >> $LOG_DIR/daily_summary.log
     free -h >> $LOG_DIR/daily_summary.log
     ```

2. 실행 권한 부여

   - `chmod +x ~/scripts/check_logs.sh`

3. cron 작업 등록
   - `(crontab -l 2>/dev/null; echo "0 0 * * * ~/scripts/check_logs.sh") | crontab -`

<br>

## 17) Docker 리소스 정리 자동화

1. Docker 정리 스크립트 파일 생성

   - `nano ~/scripts/docker_cleanup.sh`

   - 파일 작성

     ```
     #!/bin/bash
     echo "=== Docker Cleanup Started $(date) ===" >> ~/logs/docker_cleanup.log

     # 중지된 컨테이너 제거
     echo "Removing stopped containers..." >> ~/logs/docker_cleanup.log
     docker container prune -f >> ~/logs/docker_cleanup.log

     # 사용하지 않는 이미지 정리
     echo "Removing unused images..." >> ~/logs/docker_cleanup.log
     docker image prune -f >> ~/logs/docker_cleanup.log

     # 볼륨 정리
     echo "Removing unused volumes..." >> ~/logs/docker_cleanup.log
     docker volume prune -f >> ~/logs/docker_cleanup.log

     # 네트워크 정리
     echo "Removing unused networks..." >> ~/logs/docker_cleanup.log
     docker network prune -f >> ~/logs/docker_cleanup.log

     echo "=== Docker Cleanup Completed $(date) ===" >> ~/logs/docker_cleanup.log

     ```

2. 실행 권한 부여

   - `chmod +x ~/scripts/docker_cleanup.sh`

3. cron 작업 등록

   - `(crontab -l 2>/dev/null; echo "0 4 * * 0 ~/scripts/docker_cleanup.sh") | crontab -h`

<br>

## 18) 프로젝트 수동 배포

1. 프로젝트 디렉토리 생성
   - `mkdir –p ~/project`
2. Project로 이동

   - `cd ~/project`

3. 프론트엔드 프로젝트 폴더를 /home/ubuntu/project/ 디렉토리로 드래그 앤 드롭

4. 이미지 재빌드 및 컨테이너 시작
   - `sudo docker-compose up -d –build`
5. 컨테이너 상태 확인

   - `sudo docker-compose ps`

<br>

## 19) 프로젝트 폴더 제거 (필요 시)

1. 프로젝트 디렉토리로 이동
   - `cd /home/ubuntu/project/<프로젝트 폴더>
`
2. 기존 컨테이너 중지

   - `sudo docker-compose down`

3. 실행 중인 컨테이너 확인

   - `sudo docker ps`

4. 기존 프로젝트 디렉토리 삭제
   - `sudo rm -rf /home/ubuntu/project/<프로젝트 폴더>`

## 20) Jenkins로 CI/CD 설정

1. Jenkins 키 다운로드 및 저장

   - `sudo wget -O /usr/share/keyrings/jenkins-keyring.asc \
https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key`

2. Jenkins 저장소 추가

   - `echo "deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
https://pkg.jenkins.io/debian-stable binary/" | sudo tee \
/etc/apt/sources.list.d/jenkins.list > /dev/null`

3. 패키지 목록 업데이트

   - `sudo apt-get update`

4. APT를 통해 Jenkins 설치

   - `sudo apt-get install jenkins`

5. Jenkins 서비스 자동 시작 설정

   - `sudo systemctl enable jenkins`

6. Jenkins 서비스 시작

   - `sudo systemctl start jenkins`

7. Jenkins 서비스 상태 확인

   - `sudo systemctl status jenkins`

8. Jenkins 초기 비밀번호 확인

   - `sudo cat /var/lib/jenkins/secrets/initialAdminPassword`

9. Jenkins 방화벽 해제

   - `sudo ufw allow 8080`

10. 설정된 규칙 확인

    - `sudo ufw status numbered`

11. Jenkins 서버(<주소>:8080/)에 접속해서 초기 설정

12. 플러그인 설치 진행(설치가 안되는 것은 재시도하여 설치한다.)

13. Jenkins 로그인

14. Jenkins 자격 증명 설정

    A. Credential 설정

    B. Private Key에 pem 키 추가

    C. GitLab 접속용 자격 증명 추가

15. GitLab Connection 설정

16. Jenkins 파이프라인 생성과 스크립트 추가
